"""
Code to extract spectra from WHT/LIRIS

Process:
Note: Bias taken and subtracted for each exposure // Dark flats_fits not needed either.
1) Flat field correction - dome + tungsten lamp flats
2) Sky subtraction - nod pointings / near aperture
3) Curvature correction - not needed?
4) Wavelength calibration - Arc lamp spectra - Ar + Xe
5) Offset computation - header AUTOX/AUTOY / manual values
6) Spectra co-addition
7) Extraction
8) Telluric absorption correction - standard star

Target: LP 358-499 (M1V?)
Standard: HD 27267 (A0V)

To do:
- flat-fielding
- bad pixel mask - crossover and 743 in get_wav_sol
- save values used - e.g. mean rows, apertures, wavelength-pixel solution
"""

import glob, os, sys, shutil, detect_peaks
from astropy.io import fits
import matplotlib.pyplot as plt
import numpy as np
import warnings
from scipy.signal import medfilt as mf
from pysynphot import observation
from pysynphot import spectrum
warnings.filterwarnings("ignore", message="The following header keyword is invalid or follows an unrecognized "
                                          "non-standard convention")    # ignore lamp header warning
cols = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf']


def rebin_spec(wavin, specin, wavnew):
    """
    Filter spectrum to new wavelength grid
    :param wavin: Wavelength grid of spectrum
    :param specin: Spectrum to filter
    :param wavnew: New wavelength grid for spectrum
    :return: Spectrum for new wavelength grid
    """
    spec = spectrum.ArraySourceSpectrum(wave=wavin, flux=specin)
    dmy = np.ones(len(wavin))
    filt = spectrum.ArraySpectralElement(wave, dmy, waveunits='micron')
    obs = observation.Observation(spec, filt, binset=wavnew, force=['taper', 'extrap'][1])

    return obs.binflux


def sum_spectra(obj, s_row, ap=5):
    """
    Sum spectra of object - multiple images & rows
    :param obj: Object name to sum
    :param s_row: Mean pixel row of spectrum
    :param ap: Aperture size - either side of mean
    :return: Summed spectrum
    """
    n_imgs = len(all_data[obj]['raw_imgs'])
    spec = [0.0] * n_pix     # arc spectra
    for i in range(n_imgs):
        for j in range(s_row-ap, s_row+ap+1):   # rows to sum
            for k in range(n_pix):              # for each pixel in row, add to pixel counts
                spec[k] += all_data[obj]['raw_imgs'][i][j][k] / (2.0 * ap + 1.0) / n_imgs
    return spec


def get_wav_sol(arc_row_ar, arc_row_xe, grism, mfn=21, tol=0.03, poly_ord=3,
                plot_arcs=False, plot_fit=False, plot_resid=False):
    """
    Obtain wavelength solution - pixel-wavelength
    :param arc_row_ar: Argon pixel spectrum
    :param arc_row_xe: Xenon pixel spectrum
    :param grism: Grism used, e.g. hk or zj
    :param mfn: Median filter window
    :param tol: Tolerance - max distance between guess and line
    :param poly_ord: Order of polynomial fit of solution
    :param plot_arcs: Plot arc spectra & line lists
    :param plot_fit: Plot wavelength solution
    :param plot_resid: Plot residuals to solution
    :return: Wavelength at each pixel
    """

    argon_wav = np.genfromtxt('data/ar_'+grism+'.lis')
    xenon_wav = np.genfromtxt('data/xe_'+grism+'.lis')

    if plot_arcs:
        fig, ax1 = plt.subplots()  # pixel position
        ax2 = ax1.twiny()  # wavelength
        ax1.plot(x_pix, arc_row_ar)
        ax1.plot(x_pix, arc_row_xe)
        ax1.set_xlabel('Pixel number')
        ax1.set_ylabel('Intensity')
        [ax2.axvline(aw, color='k') for aw in list(argon_wav) + list(xenon_wav)]  # line list
        ax2.set_xlabel('Wavelength (microns)')
        ax2.set_xlim(wav_ranges[grism][0], wav_ranges[grism][1])
        plt.show()

    # xpos = [41.0, 58.0, 81.0, 133.0, 155.0, 270.0, 304.0, 438.0, 585.0, 591.0, 599.0, 633.0, 649.0, 674.0, 724.0, 731.0,
    #         739.0, 761.0, 780.0, 789.0, 795.0, 855.0, 1007.0]
    # ang = [0.91255, 0.9227, 0.93568, 0.96604, 0.97872, 1.04729, 1.06765, 1.14912, 1.24062, 1.24427, 1.24911, 1.27057,
    #        1.28062, 1.29602, 1.32763, 1.33168, 1.33708, 1.35079, 1.36264, 1.36823, 1.37223, 1.40975, 1.50506]

    ar_mf = arc_row_ar - mf(arc_row_ar, mfn)
    xe_mf = arc_row_xe - mf(arc_row_xe, mfn)
    lines_both = [argon_wav, xenon_wav]
    mf_both = [ar_mf, xe_mf]

    z = np.polyfit(x_pix, np.linspace(wav_ranges[grism][0], wav_ranges[grism][1], 1024), 1)
    sol = np.poly1d(z)

    # plt.plot(xpos, ang, '.', color='k')
    # plt.plot(x_pix, sol(x_pix), color='k', ls='--')

    x_g, w_g, l_g, dif = [], [], [], []
    for arc in range(2):  # each arc lamp
        xpos = list(detect_peaks.detect_peaks(mf_both[arc], mpd=7, threshold=150.0))  # pixel numbers of peaks
        lines = lines_both[arc]  # line list for lamp

        for i in range(len(xpos)):  # loop x positions of lines
            pix = xpos[i]  # pixel number
            wav_guess = sol(pix)  # guess Ar line
            li = np.argmin(abs(np.asarray(lines) - wav_guess))  # closest line to guess
            line_i = lines[li]
            dif_i = abs(wav_guess - lines[li])  # wavelength difference between guess and matched line

            if dif_i < tol and int(pix) not in [512, 513, 743, 948]:  # if match close to guess & not the chip crossover
                done = line_i in l_g  # if line already matched to a pixel
                if done:
                    j = np.argmin(abs(w_g - wav_guess))  # index in x_g, w_g, l_g, dif
                    dif_j = dif[j]

                    if dif_i < dif_j:  # if new pixel closer
                        for lis in [x_g, w_g, l_g, dif]:
                            del lis[j]

                        x_g.append(pix)  # pixel number
                        w_g.append(wav_guess)  # guess value
                        l_g.append(line_i)  # line value matched
                        dif.append(dif_i)  # difference between guess and line matched

                else:
                    x_g.append(pix)  # pixel number
                    w_g.append(wav_guess)  # guess value
                    l_g.append(line_i)  # line value matched
                    dif.append(dif_i)  # difference between guess and line matched

        if plot_fit:
            [plt.axhline(aw, color='k') for aw in lines]
            [plt.axvline(aw, color='k') for aw in xpos]

    z = np.polyfit(x_g, l_g, poly_ord)
    sol = np.poly1d(z)
    xglg = sol(x_pix)

    if plot_fit:
        plt.plot(x_pix, xglg, color='#ff7f0e', alpha=0.7, label='Fit')
        plt.plot(x_g, l_g, 'x', color='k')
        plt.xlabel('Pixel number')
        plt.ylabel('Wavelength (microns)')
        plt.legend()
        plt.show()

    if plot_resid:
        fitdif = []
        for i in range(len(x_g)):
            x = int(x_g[i])
            fit = sol(x)
            y = l_g[i]
            fitdif.append(y - fit)

        plt.plot(x_g, fitdif, 'o')
        plt.axhline(0, color='k')
        plt.show()

    return xglg


def get_mean_row(obj, lb=None, ub=None, plot_mean=False, plot_slices=False):
    """
    Get row number of slit centre
    :param obj: Object name
    :param lb: Lower bound
    :param ub: Upper bound
    :param plot_mean: Plot the mean row
    :param plot_slices: Plot slices across mean row -> aperture size
    :return: Index of mean row
    """
    rows = all_data[obj]['raw_imgs'][0]     # list of rows
    cols = rows.T                           # transpose to list of columns
    col_max = []                            # index of max of each column
    for j in range(n_pix):
        col_max.append(np.argmax(cols[j][lb:ub]))   # index of max, i.e. row number in column

    counts = np.bincount(col_max)   # count number of maxes
    s_row = np.argmax(counts)       # mean row = most common index

    if plot_mean:
        plt.plot(x_pix, col_max, '.')
        plt.axhline(s_row, ls='--', color='k')
        plt.show()

    if plot_slices:
        for j in range(200, 1001, 200):
            col = cols[j]
            i1, i2 = s_row-20, s_row+20
            plt.plot(x_pix[i1:i2], col[i1:i2], label=j)
        plt.axvline(s_row, ls='--', color='k')
        plt.legend()
        plt.show()

    return s_row


def load_model_spec(fname, wav_lims, cut=False):
    model_file = np.genfromtxt(fname, delimiter='  ', dtype=float)

    model_wav_full, model_spec_full = model_file[:, 0] / 1e4, model_file[:, 1]

    # print len(model_wav_full)

    model_wav, model_spec= [], []
    for i in range(len(model_spec_full)):
        if wav_lims[0] < model_wav_full[i] < wav_lims[1]:
            if cut:
                if i % 2 == 0:
                    model_wav.append(model_wav_full[i])
                    model_spec.append(model_spec_full[i])
            else:
                model_wav.append(model_wav_full[i])
                model_spec.append(model_spec_full[i])

    # print len(model_wav)

    if cut:
        model_wav, model_spec = model_wav[7:], model_spec[7:]

    return np.asarray(model_wav), np.asarray(model_spec) / np.nanmedian(model_spec)


# - - - - - - - -

nights = ['20170926', '20171009']       # dates of observations
ds = 1                                  # dataset to use
base_dir = nights[ds] + '/'             # folder of dataset

wav_ranges = {'hk':[1.388, 2.419], 'zj':[0.887, 1.531]}     # microns
n_pix = 1024            # number of pixels, width & height
x_pix = range(n_pix)    # pixel number along spectrum

print "> Loading data ..."

all_data = {}                           # holds data of each .fit file
obj_names, obj_use = [], []             # unique object names and object names to use
for fit_name in glob.glob(base_dir + '*.fit'):                                  # loop all .fit files
    f = fits.open(fit_name)                                                     # load data
    et_str = str(round(f[1].header['EXPTIME'], 1))
    obj = f[0].header['OBJECT'] + '_' + f[0].header['LIRGRNAM'][-2:] + '_' + et_str     # object name

    if obj not in obj_names:    # if first of object type -> add format
        all_data[obj] = {'filenames':[], 'raw_imgs':[], 'exp_times':[], 'master':[]}    # data to save

    all_data[obj]['filenames'] += [fit_name]                    # filename
    all_data[obj]['raw_imgs'] += [f[1].data]                    # raw pixel counts
    all_data[obj]['exp_times'] += [f[1].header['EXPTIME']]      # exposure time

    # print obj, f[1].header['EXPTIME'], '\t\t', fit_name
    # print all_data['DomeFlat-HK-Bright_hk']['exp_times']

    obj_names.append(obj)
    if 'acq' not in obj and obj not in obj_use:
        obj_use += [obj]

# for thing in sorted(set(obj_names)):   # sorted(obj_use):
#     print thing, '-', len(all_data[thing]['raw_imgs'])

# dmy1, dmy2 = [], []
# for key in all_data.keys():
#     dmy1 += [len(set(all_data[key]['exp_times']))]
#     dmy2 += [len(all_data[key]['exp_times'])]
# print dmy1, '\n', dmy2

# # create master flats and arcs
# for obj in obj_use:                         # loop each object + grism
#     obj_data = all_data[obj]                # all data for object + grism
#     n_imgs = len(obj_data['raw_imgs'])      # number of .fit files
#     exp_t_set = set(obj_data['exp_times'])
#
#     if len(exp_t_set) == 1:             # if single exposure time
#         print "> Creating master", obj, 'from', n_imgs, 'images ...'
#
#         exp_t = obj_data['exp_times'][0]        # exposure time in seconds
#         stack = []
#         for img in obj_data['raw_imgs']:
#             stack.append(img)
#         stack = np.dstack(stack)                # stack all images
#         med_stack = np.median(stack, axis=2)    # create median image
#         all_data[obj]['master'] = med_stack
#
#         master_obj = fits.PrimaryHDU(med_stack)
#         header = {'OBJECT':obj+'_master', 'EXPTIME':exp_t}
#         master_obj.writeto(base_dir + 'out/' + obj + '_master.fit', overwrite=True)     # save to master .fit file
#
#     # elif n_imgs == 1:       # if only one image -> copy to master .fit file
#     #     print "Copying single file to master", obj, "..."
#     #     shutil.copy(obj_data['filenames'][0], base_dir + 'out/' + obj + '_master.fit')
#
#     else:   # if multiple exposure times used -> normalise and combine
#         print "\n>", obj, "has", n_imgs, "files.", set(obj_data['exp_times'])
#         sys.exit()

# print "\n> Subtracting dims from brights.\n"
# masters = {}    # bright - dim
# for obj in obj_use:
#     if 'Bright' in obj and 'zJ' not in obj:     # Bright and Dim flats
#         sub = obj.replace('-Bright', '')
#         obj2 = obj.replace('Bright', 'Dim')
#         masters[sub] = all_data[obj]['master'] - all_data[obj2]['master']
#
#     elif 'long' in obj:     # Long and Short arcs
#         sub = obj.replace('-long', '')
#         obj2 = obj.replace('long', 'short')
#         masters[sub] = all_data[obj]['master'] - all_data[obj2]['master']
#
#     elif 'Dim' in obj or 'short' in obj:    # covered by bright/long
#         pass    # skip
#
#     else:       # no subtraction needed
#         masters[obj] = all_data[obj]['master']
# print masters.keys()

# DomeFlat_hk = all_data['DomeFlat-HK-Bright_hk']['master'] - all_data['DomeFlat-HK-Dim_hk']['master']
# DomeFlat_zj = all_data['DomeFlat-zJ-Bright_zj']['master']
# WFlat_zj = all_data['W-Flat-zJ-Bright_zj']['master']
# ArcAr_zj = all_data['Arc-Ar-long_zj']['master'] - all_data['Arc-Ar-short_zj']['master']
# ArcArXe_zj = all_data['Arc-Ar-Xe_zj']['master']
# ArcXe_zj = all_data['Arc-Xe-long_zj']['master'] - all_data['Arc-Xe-short_zj']['master']
# ArcXe_hk = all_data['Arc-Xe-long_hk']['master'] - all_data['Arc-Xe-short_hk']['master']
# ArcArXe_hk = all_data['Arc-Ar-Xe_hk']['master']
# ArcAr_hk = all_data['Arc-Ar-long_hk']['master'] - all_data['Arc-Ar-short_hk']['master']

# print "\n> All master files created."


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# try for A/hk - comparison + arcs - no flats, etc

print "> Finding wavelength solution ..."

# comp = 'A:HD27267_hk_6.0'           # Comparison star
# targ = 'A:LP358_hk_12.0'            # Target star
# arc_ar = 'Arc-Ar-long_hk_80.0'      # Argon arc
# arc_xe = 'Arc-Xe-long_hk_80.0'      # Xenon arc

comp = 'A:HD27267_zj_4.0'
targ = 'A:LP358_zj_25.0'
arc_ar = 'Arc-Ar-long_zj_15.0'
arc_xe = 'Arc-Xe-long_zj_60.0'

if 'zj' in comp:
    gr = 'zj'
else:
    gr = 'hk'


specs, wavs = [], []
for obj in [comp, targ]:
    s_row = get_mean_row(obj)      # mean row
    print "> Mean row = %d." % s_row
    arc_row_ar = sum_spectra(arc_ar, s_row)
    arc_row_xe = sum_spectra(arc_xe, s_row)

    wav_hk = get_wav_sol(arc_row_ar, arc_row_xe, grism=gr, tol=0.02)
    spec_hk = np.asarray(sum_spectra(obj, s_row))
    spec_hk /= np.nanmedian(spec_hk)

    plt.plot(wav_hk, spec_hk, label=obj)
    specs.append(spec_hk)
    wavs.append(wav_hk)

    print list(wav_hk)
    print list(spec_hk)

a0v_c_w, a0v_c_s = load_model_spec('data/uka0v.dat', wav_ranges[gr], cut=True)

# plt.plot(wavs[0], a0v_c_w)
# plt.show()

# errr = 2.0 - (specs[1] / specs[0])
# plt.plot(wavs[0], errr)

# stellar model spectra
a0v_m_w, a0v_m_s = load_model_spec('data/uka0v.dat', wav_ranges[gr])
m1v_m_w, m1v_m_s = load_model_spec('data/ukm1v.dat', wav_ranges[gr])
plt.plot(a0v_m_w, a0v_m_s, label='A0V model', color=cols[0], alpha=0.6)
plt.plot(m1v_m_w, m1v_m_s, label='M1V model', color=cols[1], alpha=0.6)

# Earth's transmission spectrum
earth_file = np.genfromtxt('data/mktrans_zm_10_10.dat')
earth_wav_full, earth_spec_full = earth_file[:,0], earth_file[:,1]
plt.plot(earth_wav_full, earth_spec_full, label='Earth', alpha=0.4)

plt.xlim(min(wav_hk), max(wav_hk))
plt.ylim(0, 3)
plt.minorticks_on()
plt.legend()
plt.show()

# with open('Ar-HD-A-lines.dat', 'w') as dat:
#     dat.write('#x_pix\twavelength\n')
#     for i in range(len(xpos)):
#         dat.write(str(xpos[i]) + '\t' + str(ang[i]) + '\n')


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# hd_a_hk_spec = [0.0] * n_pix
# for j in range(s_row-ap, s_row+ap+1):   # rows to sum
#     for k in range(n_pix):          # for each pixel in row, add to pixel counts
#         hd_a_hk_spec[k] += all_data[comp]['raw_imgs'][0][j][k] / (2.0 * ap + 1.0)
#
# a0v_file = np.genfromtxt('uka0v.dat', delimiter='  ', dtype=float)
# a0v_wav_full, a0v_spec_full = a0v_file[:, 0] / 1e4, a0v_file[:, 1]
# a0v_wav, a0v_spec, a0v_wav_c, a0v_spec_c = [], [], [], []
# for i in range(len(a0v_spec_full)):
#     if wav_ranges[arc][0] < a0v_wav_full[i] < wav_ranges[arc][1]:
#         a0v_wav.append(a0v_wav_full[i])
#         a0v_spec.append(a0v_spec_full[i])
#         if i%2==0:
#             a0v_wav_c.append(a0v_wav_full[i])
#             a0v_spec_c.append(a0v_spec_full[i])
#
# plt.plot(a0v_wav_full, a0v_spec_full, label='A0V model')
# for mv in range(0,3):
#     m_file = np.genfromtxt('ukm'+str(mv)+'v.dat', delimiter='  ', dtype=float)
#     m_wav_full, m_spec_full = m_file[:, 0] / 1e4, m_file[:, 1]
#     plt.plot(m_wav_full, m_spec_full, label='M'+str(mv)+'V model')
# for line in wav_ranges[arc]+zj_range:
#     plt.axvline(line, color='k', ls='--')
# plt.legend()
# plt.show()
#
# a0v_spec /= np.nanmedian(a0v_spec)
# hd_a_hk_spec /= np.nanmedian(hd_a_hk_spec)
# hd_a_hk_spec = hd_a_hk_spec[7:] - 0.4
# y_sol = y_sol[7:]
#
# earth_file = np.genfromtxt('mktrans_zm_10_10.dat')
# earth_wav_full, earth_spec_full = earth_file[:,0], earth_file[:,1]
#
# trend = hd_a_hk_spec / a0v_spec_c[:len(hd_a_hk_spec)]
# trend /= np.nanmedian(trend)
#
# plt.plot(y_sol, hd_a_hk_spec, label='HD27267-A-HK', zorder=1)
# plt.plot(a0v_wav, a0v_spec, label='A0V model', zorder=2)
# plt.plot(earth_wav_full, earth_spec_full, label='Earth transmission', alpha=0.4, zorder=0)
# plt.plot(y_sol, trend, label='Trend', alpha=0.6, zorder=1)
# plt.xlim(min(y_sol)-0.1, max(y_sol)+0.1)
# plt.xlabel('Wavelength (microns)')
# plt.ylabel('Normalised flux')
# plt.ylim(0, 3)
# plt.legend()
# plt.minorticks_on()
# plt.ticklabel_format(style='sci', axis='x', scilimits=(0,0))
# plt.show()

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

"""
Objects:

A:HD27267_hk_3.0 - 4                HD HK spectra - A - 3s
A:HD27267_hk_6.0 - 4                HD HK spectra - A - 6s
A:HD27267_zj_1.5 - 2                HD zJ spectra - A - 1.5s
A:HD27267_zj_4.0 - 2                HD zJ spectra - A - 4s
A:LP358_hk_12.0 - 4                 LP HK spectra - A
A:LP358_zj_25.0 - 4                 LP zJ spectra - A
Arc-Ar-Xe_hk_50.0 - 1               HK Argon + Xenon arc
Arc-Ar-Xe_zj_35.0 - 1               zJ Argon + Xenon arc
Arc-Ar-short_hk_10.0 - 2            HK Argon arc - 10s
Arc-Ar-long_hk_80.0 - 1             HK Argon arc - 80s
Arc-Ar-short_zj_3.5 - 1             zJ Argon arc - 3.5s
Arc-Ar-long_zj_15.0 - 1             zJ Argon arc - 15s
Arc-Xe-short_hk_8.0 - 1             HK Xenon arc - 8s
Arc-Xe-long_hk_80.0 - 1             HK Xenon arc - 80s
Arc-Xe-short_zj_6.0 - 1             zJ Xenon arc - 6s
Arc-Xe-long_zj_60.0 - 1             zJ Xenon arc - 60s
B:HD27267_hk_3.0 - 4                HD HK spectra - B - 3s
B:HD27267_hk_6.0 - 4                HD HK spectra - B - 6s
B:HD27267_zj_1.5 - 2                HD zJ spectra - B - 1.5s
B:HD27267_zj_4.0 - 2                HD zJ spectra - B - 4s
B:LP358_hk_12.0 - 4                 LP HK spectra - B
B:LP358_zj_25.0 - 4                 LP zJ spectra - B
DomeFlat-HK-Bright_hk_2.5 - 20      HK dome flat - bright - 2.5s
DomeFlat-HK-Bright_hk_2.7 - 1       HK dome flat - bright - 2.7s
DomeFlat-HK-Bright_hk_3.0 - 21      HK dome flat - bright - 3s
DomeFlat-HK-Dim_hk_2.5 - 20         HK dome flat - dim - 2.5s
DomeFlat-HK-Dim_hk_3.0 - 21         HK dome flat - dim - 3s
DomeFlat-zJ-Bright_zj_4.5 - 21      zJ dome flat
W-Flat-zJ-Bright_zj_1.5 - 21        zJ tungsten lamp flat

Test / acquire slit ..?
acq-slit_ar_1.0 - 2
acq-slit_ar_3.0 - 3
acq-test_ar_1.0 - 5
acq-test_ar_3.0 - 5
"""

